<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cactus Debug - 10 Solutions</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a2e; 
      color: #fff; 
      font-family: 'Segoe UI', sans-serif;
      overflow-x: auto;
    }
    h1 { 
      text-align: center; 
      padding: 20px; 
      background: #16213e;
      font-size: 24px;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      padding: 20px;
    }
    .solution {
      background: #0f3460;
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }
    .solution h3 {
      margin-bottom: 10px;
      font-size: 14px;
      color: #e94560;
    }
    .solution p {
      font-size: 11px;
      color: #aaa;
      margin-top: 8px;
      max-width: 200px;
    }
    canvas {
      border: 2px solid #e94560;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>ðŸŒµ Cactus Rendering Debug - Pick the best one!</h1>
  <div class="container" id="container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';

    const CACTUS_HEIGHT = 3;
    const CACTUS_INSET = 1/16;
    const WIDTH = 1 - CACTUS_INSET * 2;

    // Load cactus texture
    const textureLoader = new THREE.TextureLoader();
    const cactusTexture = await new Promise(resolve => {
      textureLoader.load('/textures/cactus_side.png', (tex) => {
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        tex.colorSpace = THREE.SRGBColorSpace;
        resolve(tex);
      });
    });

    // ==================== 10 DIFFERENT SOLUTIONS ====================

    // Solution 1: Simple BoxGeometry stretched (current approach)
    function solution1() {
      const geo = new THREE.BoxGeometry(WIDTH, CACTUS_HEIGHT, WIDTH);
      geo.translate(0, CACTUS_HEIGHT/2, 0);
      const tex = cactusTexture.clone();
      const mat = new THREE.MeshStandardMaterial({ map: tex });
      return new THREE.Mesh(geo, mat);
    }

    // Solution 2: BoxGeometry with repeat wrapping
    function solution2() {
      const geo = new THREE.BoxGeometry(WIDTH, CACTUS_HEIGHT, WIDTH);
      geo.translate(0, CACTUS_HEIGHT/2, 0);
      // Scale UVs for sides
      const uv = geo.getAttribute('uv');
      const normal = geo.getAttribute('normal');
      for (let i = 0; i < uv.count; i++) {
        if (Math.abs(normal.getY(i)) < 0.5) {
          uv.setY(i, uv.getY(i) * CACTUS_HEIGHT);
        }
      }
      const tex = cactusTexture.clone();
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      const mat = new THREE.MeshStandardMaterial({ map: tex });
      return new THREE.Mesh(geo, mat);
    }

    // Solution 3: Stacked individual boxes (original problem)
    function solution3() {
      const group = new THREE.Group();
      for (let y = 0; y < CACTUS_HEIGHT; y++) {
        const geo = new THREE.BoxGeometry(WIDTH, 1, WIDTH);
        const tex = cactusTexture.clone();
        const mat = new THREE.MeshStandardMaterial({ map: tex });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = y + 0.5;
        group.add(mesh);
      }
      return group;
    }

    // Solution 4: Single mesh, no internal faces, flat shading
    function solution4() {
      const geo = new THREE.BoxGeometry(WIDTH, CACTUS_HEIGHT, WIDTH);
      geo.translate(0, CACTUS_HEIGHT/2, 0);
      const tex = cactusTexture.clone();
      const mat = new THREE.MeshStandardMaterial({ 
        map: tex,
        flatShading: true 
      });
      return new THREE.Mesh(geo, mat);
    }

    // Solution 5: MeshBasicMaterial (no lighting)
    function solution5() {
      const geo = new THREE.BoxGeometry(WIDTH, CACTUS_HEIGHT, WIDTH);
      geo.translate(0, CACTUS_HEIGHT/2, 0);
      const tex = cactusTexture.clone();
      const mat = new THREE.MeshBasicMaterial({ map: tex });
      return new THREE.Mesh(geo, mat);
    }

    // Solution 6: MeshBasicMaterial with tiled UVs
    function solution6() {
      const geo = new THREE.BoxGeometry(WIDTH, CACTUS_HEIGHT, WIDTH);
      geo.translate(0, CACTUS_HEIGHT/2, 0);
      const uv = geo.getAttribute('uv');
      const normal = geo.getAttribute('normal');
      for (let i = 0; i < uv.count; i++) {
        if (Math.abs(normal.getY(i)) < 0.5) {
          uv.setY(i, uv.getY(i) * CACTUS_HEIGHT);
        }
      }
      const tex = cactusTexture.clone();
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      const mat = new THREE.MeshBasicMaterial({ map: tex });
      return new THREE.Mesh(geo, mat);
    }

    // Solution 7: Stacked boxes with MeshBasicMaterial
    function solution7() {
      const group = new THREE.Group();
      for (let y = 0; y < CACTUS_HEIGHT; y++) {
        const geo = new THREE.BoxGeometry(WIDTH, 1, WIDTH);
        const tex = cactusTexture.clone();
        const mat = new THREE.MeshBasicMaterial({ map: tex });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = y + 0.5;
        group.add(mesh);
      }
      return group;
    }

    // Solution 8: Lambert material (softer shading)
    function solution8() {
      const geo = new THREE.BoxGeometry(WIDTH, CACTUS_HEIGHT, WIDTH);
      geo.translate(0, CACTUS_HEIGHT/2, 0);
      const uv = geo.getAttribute('uv');
      const normal = geo.getAttribute('normal');
      for (let i = 0; i < uv.count; i++) {
        if (Math.abs(normal.getY(i)) < 0.5) {
          uv.setY(i, uv.getY(i) * CACTUS_HEIGHT);
        }
      }
      const tex = cactusTexture.clone();
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      const mat = new THREE.MeshLambertMaterial({ map: tex });
      return new THREE.Mesh(geo, mat);
    }

    // Solution 9: Custom geometry with merged vertices
    function solution9() {
      const hw = WIDTH / 2;
      const positions = [];
      const normals = [];
      const uvs = [];
      const indices = [];
      let idx = 0;

      const addQuad = (v0, v1, v2, v3, n, uv0, uv1, uv2, uv3) => {
        positions.push(...v0, ...v1, ...v2, ...v3);
        normals.push(...n, ...n, ...n, ...n);
        uvs.push(...uv0, ...uv1, ...uv2, ...uv3);
        indices.push(idx, idx+1, idx+2, idx, idx+2, idx+3);
        idx += 4;
      };

      // Top & bottom
      addQuad([-hw,0,hw],[hw,0,hw],[hw,0,-hw],[-hw,0,-hw], [0,-1,0], [0,0],[1,0],[1,1],[0,1]);
      addQuad([-hw,CACTUS_HEIGHT,-hw],[hw,CACTUS_HEIGHT,-hw],[hw,CACTUS_HEIGHT,hw],[-hw,CACTUS_HEIGHT,hw], [0,1,0], [0,0],[1,0],[1,1],[0,1]);
      
      // Sides - single tall quads
      addQuad([-hw,0,hw],[-hw,CACTUS_HEIGHT,hw],[hw,CACTUS_HEIGHT,hw],[hw,0,hw], [0,0,1], [0,0],[0,1],[1,1],[1,0]);
      addQuad([hw,0,-hw],[hw,CACTUS_HEIGHT,-hw],[-hw,CACTUS_HEIGHT,-hw],[-hw,0,-hw], [0,0,-1], [0,0],[0,1],[1,1],[1,0]);
      addQuad([hw,0,hw],[hw,CACTUS_HEIGHT,hw],[hw,CACTUS_HEIGHT,-hw],[hw,0,-hw], [1,0,0], [0,0],[0,1],[1,1],[1,0]);
      addQuad([-hw,0,-hw],[-hw,CACTUS_HEIGHT,-hw],[-hw,CACTUS_HEIGHT,hw],[-hw,0,hw], [-1,0,0], [0,0],[0,1],[1,1],[1,0]);

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geo.setIndex(indices);

      const tex = cactusTexture.clone();
      const mat = new THREE.MeshBasicMaterial({ map: tex });
      return new THREE.Mesh(geo, mat);
    }

    // Solution 10: Custom geometry with per-segment UVs, MeshBasicMaterial
    function solution10() {
      const hw = WIDTH / 2;
      const positions = [];
      const normals = [];
      const uvs = [];
      const indices = [];
      let idx = 0;

      const addQuad = (v0, v1, v2, v3, n, uv0, uv1, uv2, uv3) => {
        positions.push(...v0, ...v1, ...v2, ...v3);
        normals.push(...n, ...n, ...n, ...n);
        uvs.push(...uv0, ...uv1, ...uv2, ...uv3);
        indices.push(idx, idx+1, idx+2, idx, idx+2, idx+3);
        idx += 4;
      };

      // Top & bottom
      addQuad([-hw,0,hw],[hw,0,hw],[hw,0,-hw],[-hw,0,-hw], [0,-1,0], [0,0],[1,0],[1,1],[0,1]);
      addQuad([-hw,CACTUS_HEIGHT,-hw],[hw,CACTUS_HEIGHT,-hw],[hw,CACTUS_HEIGHT,hw],[-hw,CACTUS_HEIGHT,hw], [0,1,0], [0,0],[1,0],[1,1],[0,1]);
      
      // Sides - per block segment
      for (let y = 0; y < CACTUS_HEIGHT; y++) {
        addQuad([-hw,y,hw],[-hw,y+1,hw],[hw,y+1,hw],[hw,y,hw], [0,0,1], [0,0],[0,1],[1,1],[1,0]);
        addQuad([hw,y,-hw],[hw,y+1,-hw],[-hw,y+1,-hw],[-hw,y,-hw], [0,0,-1], [0,0],[0,1],[1,1],[1,0]);
        addQuad([hw,y,hw],[hw,y+1,hw],[hw,y+1,-hw],[hw,y,-hw], [1,0,0], [0,0],[0,1],[1,1],[1,0]);
        addQuad([-hw,y,-hw],[-hw,y+1,-hw],[-hw,y+1,hw],[-hw,y,hw], [-1,0,0], [0,0],[0,1],[1,1],[1,0]);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geo.setIndex(indices);

      const tex = cactusTexture.clone();
      const mat = new THREE.MeshBasicMaterial({ map: tex });
      return new THREE.Mesh(geo, mat);
    }

    // ==================== RENDERING ====================

    const solutions = [
      { fn: solution1, name: "1: Stretched Box", desc: "BoxGeometry stretched, texture stretches" },
      { fn: solution2, name: "2: Box + Tiled UV", desc: "BoxGeometry with tiled UVs + RepeatWrapping" },
      { fn: solution3, name: "3: Stacked Boxes", desc: "Individual 1x1 boxes stacked (original)" },
      { fn: solution4, name: "4: Flat Shading", desc: "Single box with flatShading=true" },
      { fn: solution5, name: "5: BasicMaterial", desc: "No lighting, texture stretched" },
      { fn: solution6, name: "6: Basic + Tiled", desc: "MeshBasicMaterial with tiled UVs" },
      { fn: solution7, name: "7: Stacked Basic", desc: "Stacked boxes with MeshBasicMaterial" },
      { fn: solution8, name: "8: Lambert Tiled", desc: "MeshLambertMaterial with tiled UVs" },
      { fn: solution9, name: "9: Custom Stretched", desc: "Custom geometry, stretched, BasicMaterial" },
      { fn: solution10, name: "10: Custom Segments", desc: "Custom geometry per-segment, BasicMaterial" },
    ];

    const container = document.getElementById('container');

    for (const sol of solutions) {
      const div = document.createElement('div');
      div.className = 'solution';
      
      const h3 = document.createElement('h3');
      h3.textContent = sol.name;
      div.appendChild(h3);

      const canvas = document.createElement('canvas');
      canvas.width = 200;
      canvas.height = 300;
      div.appendChild(canvas);

      const p = document.createElement('p');
      p.textContent = sol.desc;
      div.appendChild(p);

      container.appendChild(div);

      // Create scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xebd9a0); // Sand color

      const camera = new THREE.OrthographicCamera(-2, 2, 3, -1, 0.1, 100);
      camera.position.set(3, 3, 3);
      camera.lookAt(0, 1.5, 0);

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(5, 10, 5);
      scene.add(directional);

      // Add cactus
      try {
        const cactus = sol.fn();
        scene.add(cactus);
      } catch (e) {
        console.error(sol.name, e);
      }

      // Ground
      const groundGeo = new THREE.PlaneGeometry(4, 4);
      groundGeo.rotateX(-Math.PI / 2);
      const groundMat = new THREE.MeshBasicMaterial({ color: 0xebd9a0 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      scene.add(ground);

      // Renderer
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(200, 300);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>

